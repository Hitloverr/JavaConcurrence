import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * 即使某个对象的引用对其他线程是可见的，但不意味着对象状态对于使用该对象的线程来说一定是可见的，因此必须做好正确的同步，确保对象状态
 * 能呈现一样的视图，
 *
 * 但是任何线程都可以在不需要额外同步的情况下安全访问不可变对象，即使发布这些对象时没有使用同步。
 * 有以下几种方式：
 * 1. 在静态初始化函数中初始化一个对象引用。
 * 2. 将对象的引用保存到volatile的域中 或者 AtomicReference中
 * 3. 将对象的引用保存到某个正确构造对象的final域中。
 * 4. 将对象的引用保存到一个锁保护的域中。【比如将类放进 线程安全的容器类库】
 */
public class SafePublish {

    /**
     * 事实不可变对象：在发布后不会被修改
     * 将Date作为不可变对象来使用，Date对象的值在放入Map后就不会改变，那么synchronizedMap的同步机制就能让Date值被安全发布。
     */
    private Map<String, Date> lastLogin = Collections.synchronizedMap(new HashMap<>());

    /**
     * 不可变对象可以通过任意机制发布
     * 事实不可变对象必须通过安全方式发布
     * 可变对象必须通过安全方式发布，并且必须是线程安全的 或者某个锁保护起来。
     */

    // 当发布一个对象的时候。必须明确说明对象的访问方式。
    // 总结：在并发程序中使用和共享对象时，可以使用一些实用的策略。
    /*
    1. 线程封闭
    2. 只读共享。
    3. 线程安全共享：线程安全的对象在内部实现同步，多个线程可以通过对象的公有接口进行访问而不需要进一步同步。
    4. 保护对象：被保护的对象只能通过持有特定的锁来访问。
    * */
}
